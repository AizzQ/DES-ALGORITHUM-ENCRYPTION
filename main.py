from Crypto.Cipher import DES      # THIS IS ONLY FOR LAST TASK FOR DES ENCRYTION AS PER WRITTEN
from secrets import token_bytes    # THIS IS ALSO FOR THE LAST TASK FOR RANDOM KEY GENERATION

def bytes2binary(y):
    """
    >>> bytes2binary(b'\\x01')
    '00000001'
    >>> bytes2binary(b'\\x03')
    '00000011'
    >>> bytes2binary(b'\\xf0')
    '11110000'
    >>> bytes2binary(b'\\xf0\\x80')
    '1111000010000000'
    """

    binary_string = "{:08b}".format(int(y.hex(), 16))
    return binary_string


def binary2bytes(b):
    """
    >>> binary2bytes('00000001')
    b'\\x01'
    >>> binary2bytes('00000011')
    b'\\x03'
    >>> binary2bytes('11110000')
    b'\\xf0'
    >>> binary2bytes('1111000010000000')
    b'\\xf0\\x80'
    """
    aa = format(int(b, 2), 'x').rjust(2, '0')
    bb = bytes.fromhex(aa)
    return bb


def bin_xor(a, b):
    """
    >>> bin_xor('1011','0000')
    '1011'
    >>> bin_xor('1','0000')
    '0001'
    >>> bin_xor('1101','1011')
    '0110'
    >>> bin_xor('10101010','01010101')
    '11111111'
    """
    y = int(a, 2) ^ int(b, 2)
    y1 = ('{0:b}'.format(y)).zfill(4)
    return y1


def create_DES_subkeys(input1):
    """
    >>> create_DES_subkeys('0001001100110100010101110111100110011011101111001101111111110001')
    ['000110110000001011101111111111000111000001110010', '011110011010111011011001110110111100100111100101', '010101011111110010001010010000101100111110011001', '011100101010110111010110110110110011010100011101', '011111001110110000000111111010110101001110101000', '011000111010010100111110010100000111101100101111', '111011001000010010110111111101100001100010111100', '111101111000101000111010110000010011101111111011', '111000001101101111101011111011011110011110000001', '101100011111001101000111101110100100011001001111', '001000010101111111010011110111101101001110000110', '011101010111000111110101100101000110011111101001', '100101111100010111010001111110101011101001000001', '010111110100001110110111111100101110011100111010', '101111111001000110001101001111010011111100001010', '110010110011110110001011000011100001011111110101']
    """

    global cdn
    my_order = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44,
                36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20,
                12, 4]

    my_new_order = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31,
                    37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32]

    ret0 = []
    output1 = []
    for i in input1:
        output1.append(i)
    for i in my_order:
        ret0.append(i - 1)
    mylist = output1
    mylist = [mylist[i] for i in ret0]
    xx = "".join(mylist)
    x1 = f'{xx}'
    y = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]
    co = x1[:len(x1) // 2]
    do = x1[len(x1) // 2:]
    result = []
    for i in y:
        ret1 = []
        c1 = co[i:] + co[0: i]
        d1 = do[i:] + do[0: i]
        cdn = c1 + d1
        co = c1
        do = d1
        for item in my_new_order:
            ret1.append(item - 1)
            my_newlist = cdn
            my_newlist = [my_newlist[i] for i in ret1]
            a1 = "".join(my_newlist)
            aa2 = f'{a1}'
        result.append(aa2)
    return result


def f(ro, kk):
    '''
    >>> f('11110000101010101111000010101010', '000110110000001011101111111111000111000001110010')
    '00100011010010101010100110111011'
    '''
    global yzz
    IP = [58, 50, 42, 34, 26, 18, 10, 2,
          60, 52, 44, 36, 28, 20, 12, 4,
          62, 54, 46, 38, 30, 22, 14, 6,
          64, 56, 48, 40, 32, 24, 16, 8,
          57, 49, 41, 33, 25, 17, 9, 1,
          59, 51, 43, 35, 27, 19, 11, 3,
          61, 53, 45, 37, 29, 21, 13, 5,
          63, 55, 47, 39, 31, 23, 15, 7]

    E = [32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11, 12, 13, 12,
         13, 14, 15, 16, 17, 16, 17, 18, 19, 20, 21, 20, 21,
         22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1]
    S = \
        [
            [
                [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],
                [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],
                [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],
                [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]
            ],
            [
                [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10],
                [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5],
                [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15],
                [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]
            ],
            [
                [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8],
                [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1],
                [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7],
                [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]
            ],
            [
                [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15],
                [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9],
                [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4],
                [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]
            ],
            [
                [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9],
                [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6],
                [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14],
                [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]
            ],
            [
                [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11],
                [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8],
                [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6],
                [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]
            ],
            [
                [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1],
                [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6],
                [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2],
                [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12]
            ],
            [
                [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7],
                [1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2],
                [7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8],
                [2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]
            ]
        ]
    P = [
        16, 7, 20, 21, 29, 12, 28, 17,
        1, 15, 23, 26, 5, 18, 31, 10,
        2, 8, 24, 14, 32, 27, 3, 9,
        19, 13, 30, 6, 22, 11, 4, 25]

    S0 = []
    S1 = []
    S2 = []
    S3 = []
    S4 = []
    S5 = []
    S6 = []
    S7 = []
    SS = [S[0], S[1], S[2], S[3], S[4], S[5], S[6], S[7]]
    ret10 = []
    ret20 = []
    E1 = []
    S111 = []

    for i in IP:
        ret10.append(i - 1)
    ero = ro
    for i in E:
        E1.append(i - 1)
    ero = [ero[i] for i in E1]
    j2 = "".join(map(str, ero))
    jj_1 = f'{j2}'
    # kn = e(r-1)
    yx = int(jj_1, 2) ^ int(kk, 2)
    y1 = ('{0:b}'.format(yx)).rjust(len(kk), "0")
    bb = []
    badd = []
    badd1 = []
    for i in range(0, len(y1), 6):
        bb.append(y1[i: i + 6])
    for ii in bb:
        bs = (ii[0:1] + ii[5:])
        badd.append(int(bs, 2))
        bs1 = (ii[1:5])
        badd1.append(int(bs1, 2))
    for ik in SS:
        S111.append(ik)
        for t, tt in zip(badd, badd1):
            if ik == S[0]:
                S11 = ik[t][tt]
                S0.append(bin(S11)[2:].zfill(4))
            elif ik == S[1]:
                S11 = ik[t][tt]
                S1.append(bin(S11)[2:].zfill(4))
            elif ik == S[2]:
                S11 = ik[t][tt]
                S2.append(bin(S11)[2:].zfill(4))
            elif ik == S[3]:
                S11 = ik[t][tt]
                S3.append(bin(S11)[2:].zfill(4))
            elif ik == S[4]:
                S11 = ik[t][tt]
                S4.append(bin(S11)[2:].zfill(4))
            elif ik == S[5]:
                S11 = ik[t][tt]
                S5.append(bin(S11)[2:].zfill(4))
            elif ik == S[6]:
                S11 = ik[t][tt]
                S6.append(bin(S11)[2:].zfill(4))
            elif ik == S[7]:
                S11 = ik[t][tt]
                S7.append(bin(S11)[2:].zfill(4))

    merge = S0[0:1] + S1[1:2] + S2[2:3] + S3[3:4] + S4[4:5] + S5[5:6] + S6[6:7] + S7[7:8]
    sb = f'{"".join(merge)}'
    # again set value in given IP, (SB values)
    for ip in P:
        ret20.append(ip - 1)
    sb1 = [sb[i] for i in ret20]
    j20 = "".join(map(str, sb1))
    return j20


def encrypt_DES(key, message):
    '''
    >>> encrypt_DES(b'\\x13\\x34\\x57\\x79\\x9b\\xbc\\xdf\\xf1', b'\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef')
    b'\\x85\\xe8\\x13T\\x0f\\n\\xb4\\x05'
    '''
    global yzz  # Its a global
    global result  # global result for usage in encryption
    global cdn  # global cdn variable
    my_order = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44,
                36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20,
                12, 4]

    my_new_order = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31,
                    37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32]
    input1 = "{:08b}".format(int(key.hex(), 16)).zfill(64)
    ret0 = []
    output1 = []
    for i in input1:
        output1.append(i)
    for i in my_order:
        ret0.append(i - 1)
    mylist = output1
    mylist = [mylist[i] for i in ret0]
    xx = "".join(mylist)
    x1 = f'{xx}'
    y = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]
    co = x1[:len(x1) // 2]
    do = x1[len(x1) // 2:]
    result = []
    for i in y:
        ret1 = []
        c1 = co[i:] + co[0: i]
        d1 = do[i:] + do[0: i]
        cdn = c1 + d1
        co = c1
        do = d1
        for item in my_new_order:
            ret1.append(item - 1)
            my_newlist = cdn
            my_newlist = [my_newlist[i] for i in ret1]
            a1 = "".join(my_newlist)
            aa2 = f'{a1}'
        result.append(aa2)
    IP = [58, 50, 42, 34, 26, 18, 10, 2,
          60, 52, 44, 36, 28, 20, 12, 4,
          62, 54, 46, 38, 30, 22, 14, 6,
          64, 56, 48, 40, 32, 24, 16, 8,
          57, 49, 41, 33, 25, 17, 9, 1,
          59, 51, 43, 35, 27, 19, 11, 3,
          61, 53, 45, 37, 29, 21, 13, 5,
          63, 55, 47, 39, 31, 23, 15, 7]

    IP_inverse = [40, 8, 48, 16, 56, 24, 64, 32,
                  39, 7, 47, 15, 55, 23, 63, 31,
                  38, 6, 46, 14, 54, 22, 62, 30,
                  37, 5, 45, 13, 53, 21, 61, 29,
                  36, 4, 44, 12, 52, 20, 60, 28,
                  35, 3, 43, 11, 51, 19, 59, 27,
                  34, 2, 42, 10, 50, 18, 58, 26,
                  33, 1, 41, 9, 49, 17, 57, 25]

    E = [32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11, 12, 13, 12,
         13, 14, 15, 16, 17, 16, 17, 18, 19, 20, 21, 20, 21,
         22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1]
    S = \
        [
            [
                [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],
                [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],
                [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],
                [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]
            ],
            [
                [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10],
                [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5],
                [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15],
                [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]
            ],
            [
                [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8],
                [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1],
                [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7],
                [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]
            ],
            [
                [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15],
                [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9],
                [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4],
                [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]
            ],
            [
                [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9],
                [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6],
                [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14],
                [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]
            ],
            [
                [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11],
                [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8],
                [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6],
                [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]
            ],
            [
                [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1],
                [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6],
                [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2],
                [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12]
            ],
            [
                [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7],
                [1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2],
                [7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8],
                [2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]
            ]
        ]
    P = [
        16, 7, 20, 21, 29, 12, 28, 17,
        1, 15, 23, 26, 5, 18, 31, 10,
        2, 8, 24, 14, 32, 27, 3, 9,
        19, 13, 30, 6, 22, 11, 4, 25]

    #  (ALL KEYS GENERATED BY ABOVE FUNCTION )

    #  keyn = ['000110110000001011101111111111000111000001110010', '011110011010111011011001110110111100100111100101',
    #        '010101011111110010001010010000101100111110011001', '011100101010110111010110110110110011010100011101',
    #        '011111001110110000000111111010110101001110101000', '011000111010010100111110010100000111101100101111',
    #        '111011001000010010110111111101100001100010111100', '111101111000101000111010110000010011101111111011',
    #        '111000001101101111101011111011011110011110000001', '101100011111001101000111101110100100011001001111',
    #        '001000010101111111010011110111101101001110000110', '011101010111000111110101100101000110011111101001',
    #        '100101111100010111010001111110101011101001000001', '010111110100001110110111111100101110011100111010',
    #        '101111111001000110001101001111010011111100001010', '110010110011110110001011000011100001011111110101']



    # ALL Rn AND Ln VALUE FOR CHECKING PERPOSE


    # r1 = "11101111010010100110010101000100"
    # r2 = "11001100000000010111011100001001"
    # r3 = '10100010010111000000101111110100'
    # r4 = '01110111001000100000000001000101'
    # r5 = '10001010010011111010011000110111'
    # r6 = '11101001011001111100110101101001'
    # r7 = '00000110010010101011101000010000'
    # r8 = '11010101011010010100101110010000'
    # r9 = '00100100011111001100011001111010'
    # r10 = '10110111110101011101011110110010'
    # r11 = '11000101011110000011110001111000'
    # r12 = '01110101101111010001100001011000'
    # r13 = '00011000110000110001010101011010'
    # r14 = '11000010100011001001011000001101'
    # r15 = '01000011010000100011001000110100'  # L15
    # r16 = '00001010010011001101100110010101'  # R15

    S0 = []
    S1 = []
    S2 = []
    S3 = []
    S4 = []
    S5 = []
    S6 = []
    S7 = []
    SS = [S[0], S[1], S[2], S[3], S[4], S[5], S[6], S[7]]
    MM = "{:08b}".format(int(message.hex(), 16)).zfill(64)
    ret10 = []
    ret20 = []
    ret50 = []
    gool = []
    E1 = []
    S111 = []
    n = []
    IP10 = []
    for i in IP:
        ret10.append(i - 1)
    MM = [MM[i] for i in ret10]
    j1 = "".join(map(str, MM))
    lo = j1[:len(j1) // 2]
    ro = j1[len(j1) // 2:]
    ero = ro
    # THIS IS POSITION WHEN I DIVIDE lo and ro
    for i in E:
        E1.append(i - 1)
    # Starting of Key loop position
    for z in result:
        ero = [ero[i] for i in E1]
        j2 = "".join(map(str, ero))
        jj_1 = f'{j2}'
        lenght1 = "000110110000001011101111111111000111000001110010"
        # kn = e(r-1) and above bits only for lenght
        yx = int(jj_1, 2) ^ int(z, 2)
        y1 = ('{0:b}'.format(yx)).rjust(len(lenght1), "0")
        bb = []
        badd = []
        badd1 = []
        for i in range(0, len(y1), 6):
            bb.append(y1[i: i + 6])
        for ii in bb:
            bs = (ii[0:1] + ii[5:])
            badd.append(int(bs, 2))
            bs1 = (ii[1:5])
            badd1.append(int(bs1, 2))
        # NOW SPLITING FUNCTION STARTED
        for ik in SS:
            S111.append(ik)
            for t, tt in zip(badd, badd1):
                if ik == S[0]:
                    S11 = ik[t][tt]
                    S0.append(bin(S11)[2:].zfill(4))
                elif ik == S[1]:
                    S11 = ik[t][tt]
                    S1.append(bin(S11)[2:].zfill(4))
                elif ik == S[2]:
                    S11 = ik[t][tt]
                    S2.append(bin(S11)[2:].zfill(4))
                elif ik == S[3]:
                    S11 = ik[t][tt]
                    S3.append(bin(S11)[2:].zfill(4))
                elif ik == S[4]:
                    S11 = ik[t][tt]
                    S4.append(bin(S11)[2:].zfill(4))
                elif ik == S[5]:
                    S11 = ik[t][tt]
                    S5.append(bin(S11)[2:].zfill(4))
                elif ik == S[6]:
                    S11 = ik[t][tt]
                    S6.append(bin(S11)[2:].zfill(4))
                elif ik == S[7]:
                    S11 = ik[t][tt]
                    S7.append(bin(S11)[2:].zfill(4))
            # WE GET OUR SBOXES RESULT
        merge = S0[0:1] + S1[1:2] + S2[2:3] + S3[3:4] + S4[4:5] + S5[5:6] + S6[6:7] + S7[7:8]
        sb = f'{"".join(merge)}'
        # merging the s-boxes
        # again set value in given IP, (SB values)
        for ip in P:
            ret20.append(ip - 1)
        sb1 = [sb[i] for i in ret20]
        j20 = "".join(map(str, sb1))
        # list clearing and looping from 1
        S0.clear()
        S1.clear()
        S2.clear()
        S3.clear()
        S4.clear()
        S5.clear()
        S6.clear()
        S7.clear()
        ret20.clear()
        # list clearing and looping to all
        # xor f(ro, k)
        yz = int(j20, 2) ^ int(lo, 2)
        yzz = ('{0:b}'.format(yz)).zfill(32)
        # getting f function
        gool.append(yzz)
        ero = yzz
        if not n:
            lo = ro
        else:
            for c in n:
                lo = c
        n.append(yzz)
        rt30 = gool[15:16]
        rt40 = gool[14:15]
        # only get R16 and R15
        ret50 = "".join(rt30 + rt40)
    gl = ret50
    for ir in IP_inverse:
        IP10.append(ir - 1)
    gl = [gl[oo] for oo in IP10]
    j100 = "".join(map(str, gl))
    j200 = f'{j100}'
    aa = format(int(j200, 2), 'x').rjust(16, '0')
    bb = bytes.fromhex(aa)
    return bb


def are_random_tests_all_passes(X):
    '''
    >>> are_random_tests_all_passes(100)
    True
    '''
    for q in range(X):
        # Please see the last condition this loop runs 100 times while
        # compairing both DES and My DES. Thank you

        key = token_bytes(8)  # EVERY TIME THE SAME KEY ALSO FOR MY DES
        message = token_bytes(8)  # EVERY TIME THE SAME THIS MESSAGE ALSO USE MY DES
        cipher = DES.new(key, DES.MODE_ECB)
        cipher_text = cipher.encrypt(message)
        global yzz  # Its a global
        global result  # global result for usage in encryption
        global cdn  # global cdn variable
        my_order = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52,
                    44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5,
                    28, 20, 12, 4]

        my_new_order = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52,
                        31,
                        37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32]
        input1 = "{:08b}".format(int(key.hex(), 16)).zfill(64)
        ret0 = []
        output1 = []
        for i in input1:
            output1.append(i)
        for i in my_order:
            ret0.append(i - 1)
        mylist = output1
        mylist = [mylist[i] for i in ret0]
        xx = "".join(mylist)
        x1 = f'{xx}'
        y = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]
        co = x1[:len(x1) // 2]
        do = x1[len(x1) // 2:]
        result = []
        for i in y:
            ret1 = []
            c1 = co[i:] + co[0: i]
            d1 = do[i:] + do[0: i]
            cdn = c1 + d1
            co = c1
            do = d1
            for item in my_new_order:
                ret1.append(item - 1)
                my_newlist = cdn
                my_newlist = [my_newlist[i] for i in ret1]
                a1 = "".join(my_newlist)
                aa2 = f'{a1}'
            result.append(aa2)
        IP = [58, 50, 42, 34, 26, 18, 10, 2,
              60, 52, 44, 36, 28, 20, 12, 4,
              62, 54, 46, 38, 30, 22, 14, 6,
              64, 56, 48, 40, 32, 24, 16, 8,
              57, 49, 41, 33, 25, 17, 9, 1,
              59, 51, 43, 35, 27, 19, 11, 3,
              61, 53, 45, 37, 29, 21, 13, 5,
              63, 55, 47, 39, 31, 23, 15, 7]

        IP_inverse = [40, 8, 48, 16, 56, 24, 64, 32,
                      39, 7, 47, 15, 55, 23, 63, 31,
                      38, 6, 46, 14, 54, 22, 62, 30,
                      37, 5, 45, 13, 53, 21, 61, 29,
                      36, 4, 44, 12, 52, 20, 60, 28,
                      35, 3, 43, 11, 51, 19, 59, 27,
                      34, 2, 42, 10, 50, 18, 58, 26,
                      33, 1, 41, 9, 49, 17, 57, 25]

        E = [32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11, 12, 13, 12,
             13, 14, 15, 16, 17, 16, 17, 18, 19, 20, 21, 20, 21,
             22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1]
        S = \
            [
                [
                    [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],
                    [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],
                    [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],
                    [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]
                ],
                [
                    [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10],
                    [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5],
                    [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15],
                    [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]
                ],
                [
                    [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8],
                    [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1],
                    [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7],
                    [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]
                ],
                [
                    [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15],
                    [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9],
                    [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4],
                    [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]
                ],
                [
                    [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9],
                    [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6],
                    [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14],
                    [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]
                ],
                [
                    [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11],
                    [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8],
                    [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6],
                    [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]
                ],
                [
                    [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1],
                    [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6],
                    [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2],
                    [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12]
                ],
                [
                    [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7],
                    [1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2],
                    [7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8],
                    [2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]
                ]
            ]
        P = [
            16, 7, 20, 21, 29, 12, 28, 17,
            1, 15, 23, 26, 5, 18, 31, 10,
            2, 8, 24, 14, 32, 27, 3, 9,
            19, 13, 30, 6, 22, 11, 4, 25]

        #  (ALL KEYS GENERATED BY ABOVE FUNCTION )

        #  keyn = ['000110110000001011101111111111000111000001110010', '011110011010111011011001110110111100100111100101',
        #        '010101011111110010001010010000101100111110011001', '011100101010110111010110110110110011010100011101',
        #        '011111001110110000000111111010110101001110101000', '011000111010010100111110010100000111101100101111',
        #        '111011001000010010110111111101100001100010111100', '111101111000101000111010110000010011101111111011',
        #        '111000001101101111101011111011011110011110000001', '101100011111001101000111101110100100011001001111',
        #        '001000010101111111010011110111101101001110000110', '011101010111000111110101100101000110011111101001',
        #        '100101111100010111010001111110101011101001000001', '010111110100001110110111111100101110011100111010',
        #        '101111111001000110001101001111010011111100001010', '110010110011110110001011000011100001011111110101']

        # ALL Rn AND Ln VALUE FOR CHECKING PERPOSE

        # r1 = "11101111010010100110010101000100"
        # r2 = "11001100000000010111011100001001"
        # r3 = '10100010010111000000101111110100'
        # r4 = '01110111001000100000000001000101'
        # r5 = '10001010010011111010011000110111'
        # r6 = '11101001011001111100110101101001'
        # r7 = '00000110010010101011101000010000'
        # r8 = '11010101011010010100101110010000'
        # r9 = '00100100011111001100011001111010'
        # r10 = '10110111110101011101011110110010'
        # r11 = '11000101011110000011110001111000'
        # r12 = '01110101101111010001100001011000'
        # r13 = '00011000110000110001010101011010'
        # r14 = '11000010100011001001011000001101'
        # r15 = '01000011010000100011001000110100'  # L15
        # r16 = '00001010010011001101100110010101'  # R15

        S0 = []
        S1 = []
        S2 = []
        S3 = []
        S4 = []
        S5 = []
        S6 = []
        S7 = []
        SS = [S[0], S[1], S[2], S[3], S[4], S[5], S[6], S[7]]
        MM = "{:08b}".format(int(message.hex(), 16)).zfill(64)
        ret10 = []
        ret20 = []
        ret50 = []
        gool = []
        E1 = []
        S111 = []
        n = []
        IP10 = []
        for i in IP:
            ret10.append(i - 1)
        MM = [MM[i] for i in ret10]
        j1 = "".join(map(str, MM))
        lo = j1[:len(j1) // 2]
        ro = j1[len(j1) // 2:]
        ero = ro
        # THIS IS POSITION WHEN I DIVIDE lo and ro
        for i in E:
            E1.append(i - 1)
        # Starting of Key loop position
        for z in result:
            ero = [ero[i] for i in E1]
            j2 = "".join(map(str, ero))
            jj_1 = f'{j2}'
            lenght1 = "000110110000001011101111111111000111000001110010"
            # kn = e(r-1) and above bits only for lenght
            yx = int(jj_1, 2) ^ int(z, 2)
            y1 = ('{0:b}'.format(yx)).rjust(len(lenght1), "0")
            bb = []
            badd = []
            badd1 = []
            for i in range(0, len(y1), 6):
                bb.append(y1[i: i + 6])
            for ii in bb:
                bs = (ii[0:1] + ii[5:])
                badd.append(int(bs, 2))
                bs1 = (ii[1:5])
                badd1.append(int(bs1, 2))
            # NOW SPLITING FUNCTION STARTED
            for ik in SS:
                S111.append(ik)
                for t, tt in zip(badd, badd1):
                    if ik == S[0]:
                        S11 = ik[t][tt]
                        S0.append(bin(S11)[2:].zfill(4))
                    elif ik == S[1]:
                        S11 = ik[t][tt]
                        S1.append(bin(S11)[2:].zfill(4))
                    elif ik == S[2]:
                        S11 = ik[t][tt]
                        S2.append(bin(S11)[2:].zfill(4))
                    elif ik == S[3]:
                        S11 = ik[t][tt]
                        S3.append(bin(S11)[2:].zfill(4))
                    elif ik == S[4]:
                        S11 = ik[t][tt]
                        S4.append(bin(S11)[2:].zfill(4))
                    elif ik == S[5]:
                        S11 = ik[t][tt]
                        S5.append(bin(S11)[2:].zfill(4))
                    elif ik == S[6]:
                        S11 = ik[t][tt]
                        S6.append(bin(S11)[2:].zfill(4))
                    elif ik == S[7]:
                        S11 = ik[t][tt]
                        S7.append(bin(S11)[2:].zfill(4))
                # WE GET OUR SBOXES RESULT
            merge = S0[0:1] + S1[1:2] + S2[2:3] + S3[3:4] + S4[4:5] + S5[5:6] + S6[6:7] + S7[7:8]
            sb = f'{"".join(merge)}'
            # merging the s-boxes
            # again set value in given IP, (SB values)
            for ip in P:
                ret20.append(ip - 1)
            sb1 = [sb[i] for i in ret20]
            j20 = "".join(map(str, sb1))
            # list clearing and looping from 1
            S0.clear()
            S1.clear()
            S2.clear()
            S3.clear()
            S4.clear()
            S5.clear()
            S6.clear()
            S7.clear()
            ret20.clear()
            # list clearing and looping to all
            # xor f(ro, k)
            yz = int(j20, 2) ^ int(lo, 2)
            yzz = ('{0:b}'.format(yz)).zfill(32)
            # getting f function
            gool.append(yzz)
            ero = yzz
            if not n:
                lo = ro
            else:
                for c in n:
                    lo = c
            n.append(yzz)
            rt30 = gool[15:16]
            rt40 = gool[14:15]
            # only get R16 and R15
            ret50 = "".join(rt30 + rt40)
        gl = ret50
        for ir in IP_inverse:
            IP10.append(ir - 1)
        gl = [gl[oo] for oo in IP10]
        j100 = "".join(map(str, gl))
        j200 = f'{j100}'
        aa = format(int(j200, 2), 'x').rjust(16, '0')
        bb = bytes.fromhex(aa)
        # In above for loop q value start from 0 and end 100
        # the condition never until 100 times
        if cipher_text == bb and q == 100:
            pass
    return True

